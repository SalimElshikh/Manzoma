<?xml version="1.0" encoding="utf-8"?>
<reflection>
  <assemblies>
    <assembly name="mscorlib">
      <assemblydata version="4.0.0.0" culture="" key="00000000000000000400000000000000" hash="SHA1" />
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
        <attribute>
          <type api="T:System.Runtime.InteropServices.GuidAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>BED7F4EA-1A96-11d2-8F08-00A0C9A6186D</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Runtime.InteropServices.ComVisibleAttribute" ref="true" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>False</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.CLSCompliantAttribute" ref="true" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Security.AllowPartiallyTrustedCallersAttribute" ref="true" />
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyTitleAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>mscorlib.dll</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyDescriptionAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>mscorlib.dll</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyDefaultAliasAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>mscorlib.dll</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyCompanyAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>Microsoft Corporation</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyProductAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>Microsoft® .NET Framework</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyCopyrightAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>© Microsoft Corporation.  All rights reserved.</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyFileVersionAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>4.8.3761.0</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyInformationalVersionAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>4.8.3761.0</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Resources.SatelliteContractVersionAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>4.0.0.0</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Resources.NeutralResourcesLanguageAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>en-US</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyDelaySignAttribute" ref="true" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyKeyFileAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>f:\dd\tools\devdiv\EcmaPublicKey.snk</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblySignatureKeyAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3</value>
          </argument>
          <argument>
            <type api="T:System.String" ref="true" />
            <value>a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d</value>
          </argument>
        </attribute>
      </attributes>
    </assembly>
    <assembly name="System.Core">
      <assemblydata version="4.0.0.0" culture="" key="00000000000000000400000000000000" hash="SHA1" />
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
        <attribute>
          <type api="T:System.Security.SecurityCriticalAttribute" ref="true" />
        </attribute>
        <attribute>
          <type api="T:System.Runtime.InteropServices.ComVisibleAttribute" ref="true" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>False</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.CLSCompliantAttribute" ref="true" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Security.AllowPartiallyTrustedCallersAttribute" ref="true" />
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyTitleAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>System.Core.dll</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyDescriptionAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>System.Core.dll</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyDefaultAliasAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>System.Core.dll</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyCompanyAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>Microsoft Corporation</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyProductAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>Microsoft® .NET Framework</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyCopyrightAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>© Microsoft Corporation.  All rights reserved.</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyFileVersionAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>4.8.3761.0</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyInformationalVersionAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>4.8.3761.0</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Resources.SatelliteContractVersionAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>4.0.0.0</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Resources.NeutralResourcesLanguageAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>en-US</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyDelaySignAttribute" ref="true" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyKeyFileAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>f:\dd\tools\devdiv\EcmaPublicKey.snk</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblySignatureKeyAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3</value>
          </argument>
          <argument>
            <type api="T:System.String" ref="true" />
            <value>a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d</value>
          </argument>
        </attribute>
      </attributes>
    </assembly>
  </assemblies>
  <apis>
    <api id="N:System.Threading.Tasks">
      <topicdata group="api" />
      <apidata name="System.Threading.Tasks" group="namespace" />
      <elements>
        <element api="T:System.Threading.Tasks.Task`1" />
        <element api="T:System.Threading.Tasks.TaskFactory`1" />
        <element api="T:System.Threading.Tasks.ParallelOptions" />
        <element api="T:System.Threading.Tasks.Parallel" />
        <element api="T:System.Threading.Tasks.ParallelLoopState" />
        <element api="T:System.Threading.Tasks.ParallelLoopResult" />
        <element api="T:System.Threading.Tasks.TaskStatus" />
        <element api="T:System.Threading.Tasks.Task" />
        <element api="T:System.Threading.Tasks.TaskCreationOptions" />
        <element api="T:System.Threading.Tasks.TaskContinuationOptions" />
        <element api="T:System.Threading.Tasks.TaskCanceledException" />
        <element api="T:System.Threading.Tasks.TaskSchedulerException" />
        <element api="T:System.Threading.Tasks.TaskFactory" />
        <element api="T:System.Threading.Tasks.TaskScheduler" />
        <element api="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs" />
        <element api="T:System.Threading.Tasks.TaskCompletionSource`1" />
        <element api="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair" />
        <element api="T:System.Threading.Tasks.TaskExtensions" />
      </elements>
    </api>
    <api id="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair">
      <topicdata group="api" />
      <apidata name="ConcurrentExclusiveSchedulerPair" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="Overload:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor">
          <element api="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor" />
          <element api="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor(System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor(System.Threading.Tasks.TaskScheduler,System.Int32)" />
          <element api="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor(System.Threading.Tasks.TaskScheduler,System.Int32,System.Int32)" />
        </element>
        <element api="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.Complete" />
        <element api="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.Completion" />
        <element api="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentScheduler" />
        <element api="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ExclusiveScheduler" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.Permissions.HostProtectionAttribute" ref="true" />
          <argument>
            <type api="T:System.Security.Permissions.SecurityAction" ref="false" />
            <enumValue>
              <field name="LinkDemand" />
            </enumValue>
          </argument>
          <assignment name="Synchronization">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
          <assignment name="ExternalThreading">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
        </attribute>
      </attributes>
    </api>
    <api id="Methods.T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair">
      <topicdata name="ConcurrentExclusiveSchedulerPair" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair" />
      <apidata name="ConcurrentExclusiveSchedulerPair" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor" />
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.Complete" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair" />
      </containers>
    </api>
    <api id="Properties.T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair">
      <topicdata name="ConcurrentExclusiveSchedulerPair" group="list" subgroup="Properties" typeTopicId="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair" />
      <apidata name="ConcurrentExclusiveSchedulerPair" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor" />
      <elements>
        <element api="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.Completion" />
        <element api="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentScheduler" />
        <element api="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ExclusiveScheduler" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor">
      <topicdata name=".ctor" group="list" subgroup="overload" memberSubgroup="constructor" pseudo="true" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <elements>
        <element api="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor" />
        <element api="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor(System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor(System.Threading.Tasks.TaskScheduler,System.Int32)" />
        <element api="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor(System.Threading.Tasks.TaskScheduler,System.Int32,System.Int32)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor(System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor" />
      <parameters>
        <parameter name="taskScheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor(System.Threading.Tasks.TaskScheduler,System.Int32)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor" />
      <parameters>
        <parameter name="taskScheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
        <parameter name="maxConcurrencyLevel">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor(System.Threading.Tasks.TaskScheduler,System.Int32,System.Int32)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor" />
      <parameters>
        <parameter name="taskScheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
        <parameter name="maxConcurrencyLevel">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="maxItemsPerTask">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.Complete">
      <topicdata group="api" />
      <apidata name="Complete" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.Completion">
      <topicdata group="api" />
      <apidata name="Completion" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Completion" />
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentScheduler">
      <topicdata group="api" />
      <apidata name="ConcurrentScheduler" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_ConcurrentScheduler" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ExclusiveScheduler">
      <topicdata group="api" />
      <apidata name="ExclusiveScheduler" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_ExclusiveScheduler" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair" ref="true" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.Parallel">
      <topicdata group="api" />
      <apidata name="Parallel" group="type" subgroup="class" />
      <typedata visibility="public" abstract="true" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="Overload:System.Threading.Tasks.Parallel.For">
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
          <element api="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
          <element api="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
          <element api="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
          <element api="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
        </element>
        <element api="Overload:System.Threading.Tasks.Parallel.ForEach">
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
        </element>
        <element api="Overload:System.Threading.Tasks.Parallel.Invoke">
          <element api="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
          <element api="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
        </element>
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.Permissions.HostProtectionAttribute" ref="true" />
          <argument>
            <type api="T:System.Security.Permissions.SecurityAction" ref="false" />
            <enumValue>
              <field name="LinkDemand" />
            </enumValue>
          </argument>
          <assignment name="Synchronization">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
          <assignment name="ExternalThreading">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
        </attribute>
      </attributes>
    </api>
    <api id="Methods.T:System.Threading.Tasks.Parallel">
      <topicdata name="Parallel" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.Parallel" />
      <apidata name="Parallel" group="type" subgroup="class" />
      <typedata visibility="public" abstract="true" sealed="true" serializable="false" />
      <elements>
        <element api="Overload:System.Threading.Tasks.Parallel.For">
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
          <element api="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
          <element api="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
          <element api="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
          <element api="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
        </element>
        <element api="Overload:System.Threading.Tasks.Parallel.ForEach">
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
          <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
        </element>
        <element api="Overload:System.Threading.Tasks.Parallel.Invoke">
          <element api="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
          <element api="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
        </element>
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Parallel.For">
      <topicdata name="For" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="For" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
        <element api="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
        <element api="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
        <element api="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
        <element api="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
        <element api="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
        <element api="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
        <element api="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
        <element api="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
        <element api="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
        <element api="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
        <element api="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Parallel.ForEach">
      <topicdata name="ForEach" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
        <element api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Parallel.Invoke">
      <topicdata name="Invoke" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="Invoke" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
        <element api="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})">
      <topicdata group="api" />
      <apidata name="For" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.For" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="fromInclusive">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="toExclusive">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Int32" ref="false" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})">
      <topicdata group="api" />
      <apidata name="For" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.For" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="fromInclusive">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="toExclusive">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <type api="T:System.Int32" ref="false" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
      <topicdata group="api" />
      <apidata name="For" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.For" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TLocal" />
      </templates>
      <parameters>
        <parameter name="fromInclusive">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="toExclusive">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="localInit">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Func`4" ref="true">
            <specialization>
              <type api="T:System.Int32" ref="false" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localFinally">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})">
      <topicdata group="api" />
      <apidata name="For" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.For" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="fromInclusive">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="toExclusive">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Int32" ref="false" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})">
      <topicdata group="api" />
      <apidata name="For" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.For" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="fromInclusive">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="toExclusive">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <type api="T:System.Int32" ref="false" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
      <topicdata group="api" />
      <apidata name="For" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.For" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TLocal" />
      </templates>
      <parameters>
        <parameter name="fromInclusive">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="toExclusive">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="localInit">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Func`4" ref="true">
            <specialization>
              <type api="T:System.Int32" ref="false" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localFinally">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})">
      <topicdata group="api" />
      <apidata name="For" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.For" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="fromInclusive">
          <type api="T:System.Int64" ref="false" />
        </parameter>
        <parameter name="toExclusive">
          <type api="T:System.Int64" ref="false" />
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Int64" ref="false" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})">
      <topicdata group="api" />
      <apidata name="For" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.For" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="fromInclusive">
          <type api="T:System.Int64" ref="false" />
        </parameter>
        <parameter name="toExclusive">
          <type api="T:System.Int64" ref="false" />
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <type api="T:System.Int64" ref="false" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
      <topicdata group="api" />
      <apidata name="For" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.For" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TLocal" />
      </templates>
      <parameters>
        <parameter name="fromInclusive">
          <type api="T:System.Int64" ref="false" />
        </parameter>
        <parameter name="toExclusive">
          <type api="T:System.Int64" ref="false" />
        </parameter>
        <parameter name="localInit">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Func`4" ref="true">
            <specialization>
              <type api="T:System.Int64" ref="false" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localFinally">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})">
      <topicdata group="api" />
      <apidata name="For" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.For" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="fromInclusive">
          <type api="T:System.Int64" ref="false" />
        </parameter>
        <parameter name="toExclusive">
          <type api="T:System.Int64" ref="false" />
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Int64" ref="false" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})">
      <topicdata group="api" />
      <apidata name="For" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.For" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="fromInclusive">
          <type api="T:System.Int64" ref="false" />
        </parameter>
        <parameter name="toExclusive">
          <type api="T:System.Int64" ref="false" />
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <type api="T:System.Int64" ref="false" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
      <topicdata group="api" />
      <apidata name="For" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.For" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TLocal" />
      </templates>
      <parameters>
        <parameter name="fromInclusive">
          <type api="T:System.Int64" ref="false" />
        </parameter>
        <parameter name="toExclusive">
          <type api="T:System.Int64" ref="false" />
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="localInit">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Func`4" ref="true">
            <specialization>
              <type api="T:System.Int64" ref="false" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localFinally">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TLocal" index="0" api="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Concurrent.OrderablePartitioner`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`3" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <type api="T:System.Int64" ref="false" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
        <template name="TLocal" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Concurrent.OrderablePartitioner`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localInit">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Func`5" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <type api="T:System.Int64" ref="false" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localFinally">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Concurrent.OrderablePartitioner`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`3" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <type api="T:System.Int64" ref="false" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
        <template name="TLocal" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Concurrent.OrderablePartitioner`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="localInit">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Func`5" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <type api="T:System.Int64" ref="false" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localFinally">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Concurrent.Partitioner`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Concurrent.Partitioner`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
        <template name="TLocal" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Concurrent.Partitioner`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localInit">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Func`4" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localFinally">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Concurrent.Partitioner`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Concurrent.Partitioner`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
        <template name="TLocal" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Concurrent.Partitioner`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="localInit">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Func`4" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localFinally">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`3" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <type api="T:System.Int64" ref="false" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
        <template name="TLocal" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localInit">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Func`4" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localFinally">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
        <template name="TLocal" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localInit">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Func`5" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <type api="T:System.Int64" ref="false" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localFinally">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="body">
          <type api="T:System.Action`3" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <type api="T:System.Int64" ref="false" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
        <template name="TLocal" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="localInit">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Func`4" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localFinally">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})">
      <topicdata group="api" />
      <apidata name="ForEach" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.ForEach" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TSource" />
        <template name="TLocal" />
      </templates>
      <parameters>
        <parameter name="source">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="localInit">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="body">
          <type api="T:System.Func`5" ref="true">
            <specialization>
              <template name="TSource" index="0" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
              <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
              <type api="T:System.Int64" ref="false" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
        <parameter name="localFinally">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <template name="TLocal" index="1" api="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])">
      <topicdata group="api" />
      <apidata name="Invoke" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.Invoke" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="actions" params="true">
          <arrayOf rank="1">
            <type api="T:System.Action" ref="true" />
          </arrayOf>
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])">
      <topicdata group="api" />
      <apidata name="Invoke" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Parallel.Invoke" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="parallelOptions">
          <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
        </parameter>
        <parameter name="actions" params="true">
          <arrayOf rank="1">
            <type api="T:System.Action" ref="true" />
          </arrayOf>
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Parallel" ref="true" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.ParallelLoopResult">
      <topicdata group="api" />
      <apidata name="ParallelLoopResult" group="type" subgroup="structure" />
      <typedata visibility="public" sealed="true" serializable="false" noSettableProperties="true" />
      <family>
        <ancestors>
          <type api="T:System.ValueType" ref="true" />
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:System.Object.GetType" />
        <element api="M:System.ValueType.Equals(System.Object)" />
        <element api="M:System.ValueType.GetHashCode" />
        <element api="M:System.ValueType.ToString" />
        <element api="P:System.Threading.Tasks.ParallelLoopResult.IsCompleted" />
        <element api="P:System.Threading.Tasks.ParallelLoopResult.LowestBreakIteration" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
    </api>
    <api id="Methods.T:System.Threading.Tasks.ParallelLoopResult">
      <topicdata name="ParallelLoopResult" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.ParallelLoopResult" />
      <apidata name="ParallelLoopResult" group="type" subgroup="structure" />
      <typedata visibility="public" sealed="true" serializable="false" noSettableProperties="true" />
      <elements>
        <element api="M:System.Object.GetType" />
        <element api="M:System.ValueType.Equals(System.Object)" />
        <element api="M:System.ValueType.GetHashCode" />
        <element api="M:System.ValueType.ToString" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelLoopResult" />
      </containers>
    </api>
    <api id="Properties.T:System.Threading.Tasks.ParallelLoopResult">
      <topicdata name="ParallelLoopResult" group="list" subgroup="Properties" typeTopicId="T:System.Threading.Tasks.ParallelLoopResult" />
      <apidata name="ParallelLoopResult" group="type" subgroup="structure" />
      <typedata visibility="public" sealed="true" serializable="false" noSettableProperties="true" />
      <elements>
        <element api="P:System.Threading.Tasks.ParallelLoopResult.IsCompleted" />
        <element api="P:System.Threading.Tasks.ParallelLoopResult.LowestBreakIteration" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelLoopResult" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.ParallelLoopResult.IsCompleted">
      <topicdata group="api" />
      <apidata name="IsCompleted" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_IsCompleted" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.ParallelLoopResult.LowestBreakIteration">
      <topicdata group="api" />
      <apidata name="LowestBreakIteration" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_LowestBreakIteration" />
      <returns>
        <type api="T:System.Nullable`1" ref="false">
          <specialization>
            <type api="T:System.Int64" ref="false" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelLoopResult" ref="false" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.ParallelLoopState">
      <topicdata group="api" />
      <apidata name="ParallelLoopState" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="M:System.Threading.Tasks.ParallelLoopState.Break" />
        <element api="M:System.Threading.Tasks.ParallelLoopState.Stop" />
        <element api="P:System.Threading.Tasks.ParallelLoopState.IsExceptional" />
        <element api="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
        <element api="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
        <element api="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.Permissions.HostProtectionAttribute" ref="true" />
          <argument>
            <type api="T:System.Security.Permissions.SecurityAction" ref="false" />
            <enumValue>
              <field name="LinkDemand" />
            </enumValue>
          </argument>
          <assignment name="Synchronization">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
          <assignment name="ExternalThreading">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
        </attribute>
      </attributes>
    </api>
    <api id="Methods.T:System.Threading.Tasks.ParallelLoopState">
      <topicdata name="ParallelLoopState" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.ParallelLoopState" />
      <apidata name="ParallelLoopState" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" />
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="M:System.Threading.Tasks.ParallelLoopState.Break" />
        <element api="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelLoopState" />
      </containers>
    </api>
    <api id="Properties.T:System.Threading.Tasks.ParallelLoopState">
      <topicdata name="ParallelLoopState" group="list" subgroup="Properties" typeTopicId="T:System.Threading.Tasks.ParallelLoopState" />
      <apidata name="ParallelLoopState" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" />
      <elements>
        <element api="P:System.Threading.Tasks.ParallelLoopState.IsExceptional" />
        <element api="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
        <element api="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
        <element api="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelLoopState" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.ParallelLoopState.Break">
      <topicdata group="api" />
      <apidata name="Break" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.ParallelLoopState.IsExceptional">
      <topicdata group="api" />
      <apidata name="IsExceptional" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_IsExceptional" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.ParallelLoopState.IsStopped">
      <topicdata group="api" />
      <apidata name="IsStopped" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_IsStopped" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
      <topicdata group="api" />
      <apidata name="LowestBreakIteration" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_LowestBreakIteration" />
      <returns>
        <type api="T:System.Nullable`1" ref="false">
          <specialization>
            <type api="T:System.Int64" ref="false" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
      <topicdata group="api" />
      <apidata name="ShouldExitCurrentIteration" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_ShouldExitCurrentIteration" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.ParallelLoopState.Stop">
      <topicdata group="api" />
      <apidata name="Stop" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelLoopState" ref="true" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.ParallelOptions">
      <topicdata group="api" />
      <apidata name="ParallelOptions" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.ParallelOptions.#ctor" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="M:System.Threading.Tasks.ParallelOptions.#ctor" />
        <element api="P:System.Threading.Tasks.ParallelOptions.CancellationToken" />
        <element api="P:System.Threading.Tasks.ParallelOptions.MaxDegreeOfParallelism" />
        <element api="P:System.Threading.Tasks.ParallelOptions.TaskScheduler" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
    </api>
    <api id="Methods.T:System.Threading.Tasks.ParallelOptions">
      <topicdata name="ParallelOptions" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.ParallelOptions" />
      <apidata name="ParallelOptions" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.ParallelOptions.#ctor" />
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelOptions" />
      </containers>
    </api>
    <api id="Properties.T:System.Threading.Tasks.ParallelOptions">
      <topicdata name="ParallelOptions" group="list" subgroup="Properties" typeTopicId="T:System.Threading.Tasks.ParallelOptions" />
      <apidata name="ParallelOptions" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.ParallelOptions.#ctor" />
      <elements>
        <element api="P:System.Threading.Tasks.ParallelOptions.CancellationToken" />
        <element api="P:System.Threading.Tasks.ParallelOptions.MaxDegreeOfParallelism" />
        <element api="P:System.Threading.Tasks.ParallelOptions.TaskScheduler" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelOptions" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.ParallelOptions.#ctor">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.ParallelOptions.CancellationToken">
      <topicdata group="api" />
      <apidata name="CancellationToken" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_CancellationToken" />
      <setter name="set_CancellationToken" />
      <returns>
        <type api="T:System.Threading.CancellationToken" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.ParallelOptions.MaxDegreeOfParallelism">
      <topicdata group="api" />
      <apidata name="MaxDegreeOfParallelism" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_MaxDegreeOfParallelism" />
      <setter name="set_MaxDegreeOfParallelism" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.ParallelOptions.TaskScheduler">
      <topicdata group="api" />
      <apidata name="TaskScheduler" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_TaskScheduler" />
      <setter name="set_TaskScheduler" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.ParallelOptions" ref="true" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.Task">
      <topicdata group="api" />
      <apidata name="Task" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
        <descendents>
          <type api="T:System.Threading.Tasks.Task`1" ref="true" />
        </descendents>
      </family>
      <implements>
        <type api="T:System.IAsyncResult" ref="true" />
        <type api="T:System.IDisposable" ref="true" />
      </implements>
      <elements>
        <element api="M:System.Windows.Threading.TaskExtensions.DispatcherOperationWait(System.Threading.Tasks.Task)" source="extension" overload="true">
          <apidata name="DispatcherOperationWait" group="member" subgroup="method" subsubgroup="extension" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Windows.Threading.DispatcherOperationStatus" ref="false" />
          </returns>
          <containers>
            <library assembly="System.Windows.Presentation" module="System.Windows.Presentation" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Windows.Threading" />
            <type api="T:System.Windows.Threading.TaskExtensions" ref="true" />
          </containers>
        </element>
        <element api="M:System.Windows.Threading.TaskExtensions.DispatcherOperationWait(System.Threading.Tasks.Task,System.TimeSpan)" source="extension" overload="true">
          <apidata name="DispatcherOperationWait" group="member" subgroup="method" subsubgroup="extension" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <parameters>
            <parameter name="timeout">
              <type api="T:System.TimeSpan" ref="false" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Windows.Threading.DispatcherOperationStatus" ref="false" />
          </returns>
          <containers>
            <library assembly="System.Windows.Presentation" module="System.Windows.Presentation" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Windows.Threading" />
            <type api="T:System.Windows.Threading.TaskExtensions" ref="true" />
          </containers>
        </element>
        <element api="M:System.Windows.Threading.TaskExtensions.IsDispatcherOperationTask(System.Threading.Tasks.Task)" source="extension">
          <apidata name="IsDispatcherOperationTask" group="member" subgroup="method" subsubgroup="extension" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="System.Windows.Presentation" module="System.Windows.Presentation" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Windows.Threading" />
            <type api="T:System.Windows.Threading.TaskExtensions" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="Overload:System.Threading.Tasks.Task.#ctor">
          <element api="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
          <element api="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
          <element api="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
        </element>
        <element api="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
        <element api="Overload:System.Threading.Tasks.Task.ContinueWith">
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.Delay">
          <element api="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
          <element api="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
          <element api="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.Dispose">
          <element api="M:System.Threading.Tasks.Task.Dispose" />
          <element api="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.FromCanceled">
          <element api="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.FromException">
          <element api="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
          <element api="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
        </element>
        <element api="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
        <element api="M:System.Threading.Tasks.Task.GetAwaiter" />
        <element api="Overload:System.Threading.Tasks.Task.Run">
          <element api="M:System.Threading.Tasks.Task.Run(System.Action)" />
          <element api="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
          <element api="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
          <element api="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
          <element api="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.RunSynchronously">
          <element api="M:System.Threading.Tasks.Task.RunSynchronously" />
          <element api="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.Start">
          <element api="M:System.Threading.Tasks.Task.Start" />
          <element api="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.Wait">
          <element api="M:System.Threading.Tasks.Task.Wait" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.WaitAll">
          <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
          <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
          <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
          <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.WaitAny">
          <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
          <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
          <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
          <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.WhenAll">
          <element api="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
          <element api="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
          <element api="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
          <element api="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.WhenAny">
          <element api="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
          <element api="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
          <element api="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
          <element api="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
        </element>
        <element api="M:System.Threading.Tasks.Task.Yield" />
        <element api="P:System.Threading.Tasks.Task.AsyncState" />
        <element api="P:System.Threading.Tasks.Task.CompletedTask" />
        <element api="P:System.Threading.Tasks.Task.CreationOptions" />
        <element api="P:System.Threading.Tasks.Task.CurrentId" />
        <element api="P:System.Threading.Tasks.Task.Exception" />
        <element api="P:System.Threading.Tasks.Task.Factory" />
        <element api="P:System.Threading.Tasks.Task.Id" />
        <element api="P:System.Threading.Tasks.Task.IsCanceled" />
        <element api="P:System.Threading.Tasks.Task.IsCompleted" />
        <element api="P:System.Threading.Tasks.Task.IsFaulted" />
        <element api="P:System.Threading.Tasks.Task.Status" />
        <element api="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
        <element api="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.Permissions.HostProtectionAttribute" ref="true" />
          <argument>
            <type api="T:System.Security.Permissions.SecurityAction" ref="false" />
            <enumValue>
              <field name="LinkDemand" />
            </enumValue>
          </argument>
          <assignment name="Synchronization">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
          <assignment name="ExternalThreading">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
        </attribute>
      </attributes>
    </api>
    <api id="Methods.T:System.Threading.Tasks.Task">
      <topicdata name="Task" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.Task" />
      <apidata name="Task" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" />
      <elements>
        <element api="M:System.Windows.Threading.TaskExtensions.DispatcherOperationWait(System.Threading.Tasks.Task)" source="extension" overload="true">
          <apidata name="DispatcherOperationWait" group="member" subgroup="method" subsubgroup="extension" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Windows.Threading.DispatcherOperationStatus" ref="false" />
          </returns>
          <containers>
            <library assembly="System.Windows.Presentation" module="System.Windows.Presentation" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Windows.Threading" />
            <type api="T:System.Windows.Threading.TaskExtensions" ref="true" />
          </containers>
        </element>
        <element api="M:System.Windows.Threading.TaskExtensions.DispatcherOperationWait(System.Threading.Tasks.Task,System.TimeSpan)" source="extension" overload="true">
          <apidata name="DispatcherOperationWait" group="member" subgroup="method" subsubgroup="extension" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <parameters>
            <parameter name="timeout">
              <type api="T:System.TimeSpan" ref="false" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Windows.Threading.DispatcherOperationStatus" ref="false" />
          </returns>
          <containers>
            <library assembly="System.Windows.Presentation" module="System.Windows.Presentation" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Windows.Threading" />
            <type api="T:System.Windows.Threading.TaskExtensions" ref="true" />
          </containers>
        </element>
        <element api="M:System.Windows.Threading.TaskExtensions.IsDispatcherOperationTask(System.Threading.Tasks.Task)" source="extension">
          <apidata name="IsDispatcherOperationTask" group="member" subgroup="method" subsubgroup="extension" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="System.Windows.Presentation" module="System.Windows.Presentation" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Windows.Threading" />
            <type api="T:System.Windows.Threading.TaskExtensions" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
        <element api="Overload:System.Threading.Tasks.Task.ContinueWith">
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.Delay">
          <element api="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
          <element api="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
          <element api="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.Dispose">
          <element api="M:System.Threading.Tasks.Task.Dispose" />
          <element api="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.FromCanceled">
          <element api="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.FromException">
          <element api="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
          <element api="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
        </element>
        <element api="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
        <element api="M:System.Threading.Tasks.Task.GetAwaiter" />
        <element api="Overload:System.Threading.Tasks.Task.Run">
          <element api="M:System.Threading.Tasks.Task.Run(System.Action)" />
          <element api="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
          <element api="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
          <element api="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
          <element api="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.RunSynchronously">
          <element api="M:System.Threading.Tasks.Task.RunSynchronously" />
          <element api="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.Start">
          <element api="M:System.Threading.Tasks.Task.Start" />
          <element api="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.Wait">
          <element api="M:System.Threading.Tasks.Task.Wait" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.WaitAll">
          <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
          <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
          <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
          <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.WaitAny">
          <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
          <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
          <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
          <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.WhenAll">
          <element api="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
          <element api="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
          <element api="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
          <element api="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task.WhenAny">
          <element api="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
          <element api="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
          <element api="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
          <element api="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
        </element>
        <element api="M:System.Threading.Tasks.Task.Yield" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" />
      </containers>
    </api>
    <api id="Properties.T:System.Threading.Tasks.Task">
      <topicdata name="Task" group="list" subgroup="Properties" typeTopicId="T:System.Threading.Tasks.Task" />
      <apidata name="Task" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" />
      <elements>
        <element api="P:System.Threading.Tasks.Task.AsyncState" />
        <element api="P:System.Threading.Tasks.Task.CompletedTask" />
        <element api="P:System.Threading.Tasks.Task.CreationOptions" />
        <element api="P:System.Threading.Tasks.Task.CurrentId" />
        <element api="P:System.Threading.Tasks.Task.Exception" />
        <element api="P:System.Threading.Tasks.Task.Factory" />
        <element api="P:System.Threading.Tasks.Task.Id" />
        <element api="P:System.Threading.Tasks.Task.IsCanceled" />
        <element api="P:System.Threading.Tasks.Task.IsCompleted" />
        <element api="P:System.Threading.Tasks.Task.IsFaulted" />
        <element api="P:System.Threading.Tasks.Task.Status" />
        <element api="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
        <element api="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task.#ctor">
      <topicdata name=".ctor" group="list" subgroup="overload" memberSubgroup="constructor" pseudo="true" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
        <element api="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
        <element api="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task.ContinueWith">
      <topicdata name="ContinueWith" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task.Delay">
      <topicdata name="Delay" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="Delay" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
        <element api="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
        <element api="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task.Dispose">
      <topicdata name="Dispose" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="Dispose" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.Dispose" />
        <element api="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task.FromCanceled">
      <topicdata name="FromCanceled" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="FromCanceled" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task.FromException">
      <topicdata name="FromException" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="FromException" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
        <element api="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task.Run">
      <topicdata name="Run" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="Run" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.Run(System.Action)" />
        <element api="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
        <element api="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
        <element api="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
        <element api="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task.RunSynchronously">
      <topicdata name="RunSynchronously" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="RunSynchronously" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.RunSynchronously" />
        <element api="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task.Start">
      <topicdata name="Start" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="Start" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.Start" />
        <element api="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task.Wait">
      <topicdata name="Wait" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="Wait" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.Wait" />
        <element api="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
        <element api="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
        <element api="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task.WaitAll">
      <topicdata name="WaitAll" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="WaitAll" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
        <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
        <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
        <element api="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task.WaitAny">
      <topicdata name="WaitAny" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="WaitAny" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
        <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
        <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
        <element api="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task.WhenAll">
      <topicdata name="WhenAll" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="WhenAll" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
        <element api="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
        <element api="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
        <element api="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task.WhenAny">
      <topicdata name="WhenAny" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="WhenAny" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
        <element api="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
        <element api="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
        <element api="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.#ctor(System.Action)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task.#ctor" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task.#ctor" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task.#ctor" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task.#ctor" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task.#ctor" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task.#ctor" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task.#ctor" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task.#ctor" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task.AsyncState">
      <topicdata group="api" />
      <apidata name="AsyncState" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" />
      <getter name="get_AsyncState" />
      <returns>
        <type api="T:System.Object" ref="true" />
      </returns>
      <implements>
        <member api="P:System.IAsyncResult.AsyncState">
          <type api="T:System.IAsyncResult" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task.CompletedTask">
      <topicdata group="api" />
      <apidata name="CompletedTask" group="member" subgroup="property" />
      <memberdata visibility="public" static="true" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_CompletedTask" />
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)">
      <topicdata group="api" />
      <apidata name="ConfigureAwait" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continueOnCapturedContext">
          <type api="T:System.Boolean" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Runtime.CompilerServices.ConfiguredTaskAwaitable" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task.CreationOptions">
      <topicdata group="api" />
      <apidata name="CreationOptions" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_CreationOptions" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task.CurrentId">
      <topicdata group="api" />
      <apidata name="CurrentId" group="member" subgroup="property" />
      <memberdata visibility="public" static="true" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_CurrentId" />
      <returns>
        <type api="T:System.Nullable`1" ref="false">
          <specialization>
            <type api="T:System.Int32" ref="false" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Delay(System.Int32)">
      <topicdata group="api" />
      <apidata name="Delay" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.Delay" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="millisecondsDelay">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="Delay" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.Delay" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="millisecondsDelay">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
      <topicdata group="api" />
      <apidata name="Delay" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.Delay" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="delay">
          <type api="T:System.TimeSpan" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="Delay" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.Delay" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="delay">
          <type api="T:System.TimeSpan" ref="false" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Dispose">
      <topicdata group="api" />
      <apidata name="Dispose" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.Dispose" />
      <proceduredata virtual="true" final="true" />
      <implements>
        <member api="M:System.IDisposable.Dispose">
          <type api="T:System.IDisposable" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
      <topicdata group="api" />
      <apidata name="Dispose" group="member" subgroup="method" />
      <memberdata visibility="family" overload="Overload:System.Threading.Tasks.Task.Dispose" />
      <proceduredata virtual="true" />
      <parameters>
        <parameter name="disposing">
          <type api="T:System.Boolean" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task.Exception">
      <topicdata group="api" />
      <apidata name="Exception" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Exception" />
      <returns>
        <type api="T:System.AggregateException" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task.Factory">
      <topicdata group="api" />
      <apidata name="Factory" group="member" subgroup="property" />
      <memberdata visibility="public" static="true" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Factory" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="FromCanceled" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.FromCanceled" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="FromCanceled" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.FromCanceled" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.FromException(System.Exception)">
      <topicdata group="api" />
      <apidata name="FromException" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.FromException" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="exception">
          <type api="T:System.Exception" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
      <topicdata group="api" />
      <apidata name="FromException" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.FromException" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="exception">
          <type api="T:System.Exception" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.FromResult``1(``0)">
      <topicdata group="api" />
      <apidata name="FromResult" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="result">
          <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.GetAwaiter">
      <topicdata group="api" />
      <apidata name="GetAwaiter" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <returns>
        <type api="T:System.Runtime.CompilerServices.TaskAwaiter" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task.Id">
      <topicdata group="api" />
      <apidata name="Id" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Id" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task.IsCanceled">
      <topicdata group="api" />
      <apidata name="IsCanceled" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_IsCanceled" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task.IsCompleted">
      <topicdata group="api" />
      <apidata name="IsCompleted" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" />
      <getter name="get_IsCompleted" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="P:System.IAsyncResult.IsCompleted">
          <type api="T:System.IAsyncResult" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task.IsFaulted">
      <topicdata group="api" />
      <apidata name="IsFaulted" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_IsFaulted" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Run(System.Action)">
      <topicdata group="api" />
      <apidata name="Run" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.Run" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="Run" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.Run" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
      <topicdata group="api" />
      <apidata name="Run" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.Run" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
                </specialization>
              </type>
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="Run" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.Run" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
                </specialization>
              </type>
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
      <topicdata group="api" />
      <apidata name="Run" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.Run" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="Run" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.Run" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
      <topicdata group="api" />
      <apidata name="Run" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.Run" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="Run" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.Run" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.RunSynchronously">
      <topicdata group="api" />
      <apidata name="RunSynchronously" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.RunSynchronously" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="RunSynchronously" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.RunSynchronously" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Start">
      <topicdata group="api" />
      <apidata name="Start" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.Start" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="Start" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.Start" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task.Status">
      <topicdata group="api" />
      <apidata name="Status" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Status" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
      <topicdata group="api" eiiName="IAsyncResult.AsyncWaitHandle" />
      <apidata name="AsyncWaitHandle" group="member" subgroup="property" />
      <memberdata visibility="private" />
      <proceduredata virtual="true" final="true" eii="true" />
      <propertydata get="true" />
      <getter name="get_System.IAsyncResult.AsyncWaitHandle" />
      <returns>
        <type api="T:System.Threading.WaitHandle" ref="true" />
      </returns>
      <implements>
        <member api="P:System.IAsyncResult.AsyncWaitHandle">
          <type api="T:System.IAsyncResult" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously">
      <topicdata group="api" eiiName="IAsyncResult.CompletedSynchronously" />
      <apidata name="CompletedSynchronously" group="member" subgroup="property" />
      <memberdata visibility="private" />
      <proceduredata virtual="true" final="true" eii="true" />
      <propertydata get="true" />
      <getter name="get_System.IAsyncResult.CompletedSynchronously" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="P:System.IAsyncResult.CompletedSynchronously">
          <type api="T:System.IAsyncResult" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Wait">
      <topicdata group="api" />
      <apidata name="Wait" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.Wait" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Wait(System.Int32)">
      <topicdata group="api" />
      <apidata name="Wait" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.Wait" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="millisecondsTimeout">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="Wait" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.Wait" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="millisecondsTimeout">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="Wait" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.Wait" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
      <topicdata group="api" />
      <apidata name="Wait" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task.Wait" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="timeout">
          <type api="T:System.TimeSpan" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
      <topicdata group="api" />
      <apidata name="WaitAll" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WaitAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks" params="true">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
      <topicdata group="api" />
      <apidata name="WaitAll" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WaitAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="millisecondsTimeout">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="WaitAll" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WaitAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="millisecondsTimeout">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="WaitAll" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WaitAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
      <topicdata group="api" />
      <apidata name="WaitAll" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WaitAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="timeout">
          <type api="T:System.TimeSpan" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
      <topicdata group="api" />
      <apidata name="WaitAny" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WaitAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks" params="true">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
      <topicdata group="api" />
      <apidata name="WaitAny" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WaitAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="millisecondsTimeout">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="WaitAny" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WaitAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="millisecondsTimeout">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="WaitAny" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WaitAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
      <topicdata group="api" />
      <apidata name="WaitAny" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WaitAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="timeout">
          <type api="T:System.TimeSpan" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
      <topicdata group="api" />
      <apidata name="WhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
                </specialization>
              </type>
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <arrayOf rank="1">
              <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
            </arrayOf>
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
      <topicdata group="api" />
      <apidata name="WhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WhenAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
      <topicdata group="api" />
      <apidata name="WhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WhenAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks" params="true">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
      <topicdata group="api" />
      <apidata name="WhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks" params="true">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <arrayOf rank="1">
              <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
            </arrayOf>
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
      <topicdata group="api" />
      <apidata name="WhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
                </specialization>
              </type>
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
              </specialization>
            </type>
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
      <topicdata group="api" />
      <apidata name="WhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WhenAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
      <topicdata group="api" />
      <apidata name="WhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WhenAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks" params="true">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
      <topicdata group="api" />
      <apidata name="WhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.Task.WhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks" params="true">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TResult" index="0" api="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
              </specialization>
            </type>
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task.Yield">
      <topicdata group="api" />
      <apidata name="Yield" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <proceduredata virtual="false" />
      <returns>
        <type api="T:System.Runtime.CompilerServices.YieldAwaitable" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.Task`1">
      <topicdata group="api" />
      <apidata name="Task" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Threading.Tasks.Task" ref="true" />
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <templates>
        <template name="TResult" />
      </templates>
      <elements>
        <element api="M:System.Windows.Threading.TaskExtensions.DispatcherOperationWait(System.Threading.Tasks.Task)" source="extension" overload="true">
          <apidata name="DispatcherOperationWait" group="member" subgroup="method" subsubgroup="extension" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Windows.Threading.DispatcherOperationStatus" ref="false" />
          </returns>
          <containers>
            <library assembly="System.Windows.Presentation" module="System.Windows.Presentation" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Windows.Threading" />
            <type api="T:System.Windows.Threading.TaskExtensions" ref="true" />
          </containers>
        </element>
        <element api="M:System.Windows.Threading.TaskExtensions.DispatcherOperationWait(System.Threading.Tasks.Task,System.TimeSpan)" source="extension" overload="true">
          <apidata name="DispatcherOperationWait" group="member" subgroup="method" subsubgroup="extension" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <parameters>
            <parameter name="timeout">
              <type api="T:System.TimeSpan" ref="false" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Windows.Threading.DispatcherOperationStatus" ref="false" />
          </returns>
          <containers>
            <library assembly="System.Windows.Presentation" module="System.Windows.Presentation" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Windows.Threading" />
            <type api="T:System.Windows.Threading.TaskExtensions" ref="true" />
          </containers>
        </element>
        <element api="M:System.Windows.Threading.TaskExtensions.IsDispatcherOperationTask(System.Threading.Tasks.Task)" source="extension">
          <apidata name="IsDispatcherOperationTask" group="member" subgroup="method" subsubgroup="extension" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="System.Windows.Presentation" module="System.Windows.Presentation" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Windows.Threading" />
            <type api="T:System.Windows.Threading.TaskExtensions" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="Overload:System.Threading.Tasks.Task`1.Dispose">
          <element api="M:System.Threading.Tasks.Task.Dispose" />
          <element api="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task`1.RunSynchronously">
          <element api="M:System.Threading.Tasks.Task.RunSynchronously" />
          <element api="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task`1.Start">
          <element api="M:System.Threading.Tasks.Task.Start" />
          <element api="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task`1.Wait">
          <element api="M:System.Threading.Tasks.Task.Wait" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task`1.#ctor">
          <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0})" />
          <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object)" />
          <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
        </element>
        <element api="M:System.Threading.Tasks.Task`1.ConfigureAwait(System.Boolean)" />
        <element api="Overload:System.Threading.Tasks.Task`1.ContinueWith">
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0})" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="M:System.Threading.Tasks.Task`1.GetAwaiter" />
        <element api="P:System.Threading.Tasks.Task.AsyncState" />
        <element api="P:System.Threading.Tasks.Task.CreationOptions" />
        <element api="P:System.Threading.Tasks.Task.Exception" />
        <element api="P:System.Threading.Tasks.Task.Id" />
        <element api="P:System.Threading.Tasks.Task.IsCanceled" />
        <element api="P:System.Threading.Tasks.Task.IsCompleted" />
        <element api="P:System.Threading.Tasks.Task.IsFaulted" />
        <element api="P:System.Threading.Tasks.Task.Status" />
        <element api="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
        <element api="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
        <element api="P:System.Threading.Tasks.Task`1.Factory" />
        <element api="P:System.Threading.Tasks.Task`1.Result" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.Permissions.HostProtectionAttribute" ref="true" />
          <argument>
            <type api="T:System.Security.Permissions.SecurityAction" ref="false" />
            <enumValue>
              <field name="LinkDemand" />
            </enumValue>
          </argument>
          <assignment name="Synchronization">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
          <assignment name="ExternalThreading">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
        </attribute>
      </attributes>
    </api>
    <api id="Methods.T:System.Threading.Tasks.Task`1">
      <topicdata name="Task" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.Task`1" />
      <apidata name="Task" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <elements>
        <element api="M:System.Windows.Threading.TaskExtensions.DispatcherOperationWait(System.Threading.Tasks.Task)" source="extension" overload="true">
          <apidata name="DispatcherOperationWait" group="member" subgroup="method" subsubgroup="extension" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Windows.Threading.DispatcherOperationStatus" ref="false" />
          </returns>
          <containers>
            <library assembly="System.Windows.Presentation" module="System.Windows.Presentation" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Windows.Threading" />
            <type api="T:System.Windows.Threading.TaskExtensions" ref="true" />
          </containers>
        </element>
        <element api="M:System.Windows.Threading.TaskExtensions.DispatcherOperationWait(System.Threading.Tasks.Task,System.TimeSpan)" source="extension" overload="true">
          <apidata name="DispatcherOperationWait" group="member" subgroup="method" subsubgroup="extension" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <parameters>
            <parameter name="timeout">
              <type api="T:System.TimeSpan" ref="false" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Windows.Threading.DispatcherOperationStatus" ref="false" />
          </returns>
          <containers>
            <library assembly="System.Windows.Presentation" module="System.Windows.Presentation" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Windows.Threading" />
            <type api="T:System.Windows.Threading.TaskExtensions" ref="true" />
          </containers>
        </element>
        <element api="M:System.Windows.Threading.TaskExtensions.IsDispatcherOperationTask(System.Threading.Tasks.Task)" source="extension">
          <apidata name="IsDispatcherOperationTask" group="member" subgroup="method" subsubgroup="extension" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="System.Windows.Presentation" module="System.Windows.Presentation" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Windows.Threading" />
            <type api="T:System.Windows.Threading.TaskExtensions" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="Overload:System.Threading.Tasks.Task`1.Dispose">
          <element api="M:System.Threading.Tasks.Task.Dispose" />
          <element api="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task`1.RunSynchronously">
          <element api="M:System.Threading.Tasks.Task.RunSynchronously" />
          <element api="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task`1.Start">
          <element api="M:System.Threading.Tasks.Task.Start" />
          <element api="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.Task`1.Wait">
          <element api="M:System.Threading.Tasks.Task.Wait" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
          <element api="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
        </element>
        <element api="M:System.Threading.Tasks.Task`1.ConfigureAwait(System.Boolean)" />
        <element api="Overload:System.Threading.Tasks.Task`1.ContinueWith">
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0})" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="M:System.Threading.Tasks.Task`1.GetAwaiter" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" />
      </containers>
    </api>
    <api id="Properties.T:System.Threading.Tasks.Task`1">
      <topicdata name="Task" group="list" subgroup="Properties" typeTopicId="T:System.Threading.Tasks.Task`1" />
      <apidata name="Task" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <elements>
        <element api="P:System.Threading.Tasks.Task.AsyncState" />
        <element api="P:System.Threading.Tasks.Task.CreationOptions" />
        <element api="P:System.Threading.Tasks.Task.Exception" />
        <element api="P:System.Threading.Tasks.Task.Id" />
        <element api="P:System.Threading.Tasks.Task.IsCanceled" />
        <element api="P:System.Threading.Tasks.Task.IsCompleted" />
        <element api="P:System.Threading.Tasks.Task.IsFaulted" />
        <element api="P:System.Threading.Tasks.Task.Status" />
        <element api="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
        <element api="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
        <element api="P:System.Threading.Tasks.Task`1.Factory" />
        <element api="P:System.Threading.Tasks.Task`1.Result" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task`1.#ctor">
      <topicdata name=".ctor" group="list" subgroup="overload" memberSubgroup="constructor" pseudo="true" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <elements>
        <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0})" />
        <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object)" />
        <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.Task`1.ContinueWith">
      <topicdata name="ContinueWith" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0})" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0})">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task`1.#ctor" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task`1.#ctor" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task`1.#ctor" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task`1.#ctor" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task`1.#ctor" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task`1.#ctor" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task`1.#ctor" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.Task`1.#ctor" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ConfigureAwait(System.Boolean)">
      <topicdata group="api" />
      <apidata name="ConfigureAwait" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continueOnCapturedContext">
          <type api="T:System.Boolean" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1" ref="false">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
            </specialization>
          </type>
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="continuationAction">
          <type api="T:System.Action`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0})">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TNewResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0})" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TNewResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TNewResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TNewResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskContinuationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskContinuationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TNewResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TNewResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <type api="T:System.Object" ref="true" />
              <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TNewResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <type api="T:System.Object" ref="true" />
              <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TNewResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <type api="T:System.Object" ref="true" />
              <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TNewResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <type api="T:System.Object" ref="true" />
              <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWith" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.Task`1.ContinueWith" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TNewResult" />
      </templates>
      <parameters>
        <parameter name="continuationFunction">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
                </specialization>
              </type>
              <type api="T:System.Object" ref="true" />
              <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TNewResult" index="0" api="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task`1.Factory">
      <topicdata group="api" />
      <apidata name="Factory" group="member" subgroup="property" />
      <memberdata visibility="public" static="true" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Factory" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.Task`1.GetAwaiter">
      <topicdata group="api" />
      <apidata name="GetAwaiter" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <returns>
        <type api="T:System.Runtime.CompilerServices.TaskAwaiter`1" ref="false">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.Task`1.Result">
      <topicdata group="api" />
      <apidata name="Result" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Result" />
      <returns>
        <template name="TResult" index="0" api="T:System.Threading.Tasks.Task`1" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.Task`1" ref="true" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.TaskCanceledException">
      <topicdata group="api" />
      <apidata name="TaskCanceledException" group="type" subgroup="class" />
      <typedata visibility="public" serializable="true" defaultConstructor="M:System.Threading.Tasks.TaskCanceledException.#ctor" />
      <family>
        <ancestors>
          <type api="T:System.OperationCanceledException" ref="true" />
          <type api="T:System.SystemException" ref="true" />
          <type api="T:System.Exception" ref="true" />
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="E:System.Exception.SerializeObjectState" />
        <element api="M:System.Exception.GetBaseException" />
        <element api="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
        <element api="M:System.Exception.GetType" />
        <element api="M:System.Exception.ToString" />
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="Overload:System.Threading.Tasks.TaskCanceledException.#ctor">
          <element api="M:System.Threading.Tasks.TaskCanceledException.#ctor" />
          <element api="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.String)" />
          <element api="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.Threading.Tasks.Task)" />
          <element api="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
          <element api="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.String,System.Exception)" />
        </element>
        <element api="P:System.Exception.Data" />
        <element api="P:System.Exception.HelpLink" />
        <element api="P:System.Exception.HResult" />
        <element api="P:System.Exception.InnerException" />
        <element api="P:System.Exception.Message" />
        <element api="P:System.Exception.Source" />
        <element api="P:System.Exception.StackTrace" />
        <element api="P:System.Exception.TargetSite" />
        <element api="P:System.OperationCanceledException.CancellationToken" />
        <element api="P:System.Threading.Tasks.TaskCanceledException.Task" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
    </api>
    <api id="Methods.T:System.Threading.Tasks.TaskCanceledException">
      <topicdata name="TaskCanceledException" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.TaskCanceledException" />
      <apidata name="TaskCanceledException" group="type" subgroup="class" />
      <typedata visibility="public" serializable="true" defaultConstructor="M:System.Threading.Tasks.TaskCanceledException.#ctor" />
      <elements>
        <element api="M:System.Exception.GetBaseException" />
        <element api="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
        <element api="M:System.Exception.GetType" />
        <element api="M:System.Exception.ToString" />
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.MemberwiseClone" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCanceledException" />
      </containers>
    </api>
    <api id="Properties.T:System.Threading.Tasks.TaskCanceledException">
      <topicdata name="TaskCanceledException" group="list" subgroup="Properties" typeTopicId="T:System.Threading.Tasks.TaskCanceledException" />
      <apidata name="TaskCanceledException" group="type" subgroup="class" />
      <typedata visibility="public" serializable="true" defaultConstructor="M:System.Threading.Tasks.TaskCanceledException.#ctor" />
      <elements>
        <element api="P:System.Exception.Data" />
        <element api="P:System.Exception.HelpLink" />
        <element api="P:System.Exception.HResult" />
        <element api="P:System.Exception.InnerException" />
        <element api="P:System.Exception.Message" />
        <element api="P:System.Exception.Source" />
        <element api="P:System.Exception.StackTrace" />
        <element api="P:System.Exception.TargetSite" />
        <element api="P:System.OperationCanceledException.CancellationToken" />
        <element api="P:System.Threading.Tasks.TaskCanceledException.Task" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCanceledException" />
      </containers>
    </api>
    <api id="Events.T:System.Threading.Tasks.TaskCanceledException">
      <topicdata name="TaskCanceledException" group="list" subgroup="Events" typeTopicId="T:System.Threading.Tasks.TaskCanceledException" />
      <apidata name="TaskCanceledException" group="type" subgroup="class" />
      <typedata visibility="public" serializable="true" defaultConstructor="M:System.Threading.Tasks.TaskCanceledException.#ctor" />
      <elements>
        <element api="E:System.Exception.SerializeObjectState" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCanceledException" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskCanceledException.#ctor">
      <topicdata name=".ctor" group="list" subgroup="overload" memberSubgroup="constructor" pseudo="true" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskCanceledException.#ctor" />
        <element api="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.String)" />
        <element api="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.Threading.Tasks.Task)" />
        <element api="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
        <element api="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.String,System.Exception)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCanceledException" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCanceledException.#ctor">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskCanceledException.#ctor" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCanceledException" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="family" special="true" overload="Overload:System.Threading.Tasks.TaskCanceledException.#ctor" />
      <parameters>
        <parameter name="info">
          <type api="T:System.Runtime.Serialization.SerializationInfo" ref="true" />
        </parameter>
        <parameter name="context">
          <type api="T:System.Runtime.Serialization.StreamingContext" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCanceledException" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.String)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskCanceledException.#ctor" />
      <parameters>
        <parameter name="message">
          <type api="T:System.String" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCanceledException" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.String,System.Exception)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskCanceledException.#ctor" />
      <parameters>
        <parameter name="message">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="innerException">
          <type api="T:System.Exception" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCanceledException" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.Threading.Tasks.Task)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskCanceledException.#ctor" />
      <parameters>
        <parameter name="task">
          <type api="T:System.Threading.Tasks.Task" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCanceledException" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.TaskCanceledException.Task">
      <topicdata group="api" />
      <apidata name="Task" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Task" />
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCanceledException" ref="true" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.TaskCompletionSource`1">
      <topicdata group="api" />
      <apidata name="TaskCompletionSource" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <templates>
        <template name="TResult" />
      </templates>
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="Overload:System.Threading.Tasks.TaskCompletionSource`1.#ctor">
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor" />
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Object)" />
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </element>
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.SetCanceled" />
        <element api="Overload:System.Threading.Tasks.TaskCompletionSource`1.SetException">
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Exception)" />
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Collections.Generic.IEnumerable{System.Exception})" />
        </element>
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.SetResult(`0)" />
        <element api="Overload:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled">
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled" />
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled(System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskCompletionSource`1.TrySetException">
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Exception)" />
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Collections.Generic.IEnumerable{System.Exception})" />
        </element>
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetResult(`0)" />
        <element api="P:System.Threading.Tasks.TaskCompletionSource`1.Task" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.Permissions.HostProtectionAttribute" ref="true" />
          <argument>
            <type api="T:System.Security.Permissions.SecurityAction" ref="false" />
            <enumValue>
              <field name="LinkDemand" />
            </enumValue>
          </argument>
          <assignment name="Synchronization">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
          <assignment name="ExternalThreading">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
        </attribute>
      </attributes>
    </api>
    <api id="Methods.T:System.Threading.Tasks.TaskCompletionSource`1">
      <topicdata name="TaskCompletionSource" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.TaskCompletionSource`1" />
      <apidata name="TaskCompletionSource" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor" />
      <templates>
        <template name="TResult" />
      </templates>
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.SetCanceled" />
        <element api="Overload:System.Threading.Tasks.TaskCompletionSource`1.SetException">
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Exception)" />
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Collections.Generic.IEnumerable{System.Exception})" />
        </element>
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.SetResult(`0)" />
        <element api="Overload:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled">
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled" />
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled(System.Threading.CancellationToken)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskCompletionSource`1.TrySetException">
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Exception)" />
          <element api="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Collections.Generic.IEnumerable{System.Exception})" />
        </element>
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetResult(`0)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" />
      </containers>
    </api>
    <api id="Properties.T:System.Threading.Tasks.TaskCompletionSource`1">
      <topicdata name="TaskCompletionSource" group="list" subgroup="Properties" typeTopicId="T:System.Threading.Tasks.TaskCompletionSource`1" />
      <apidata name="TaskCompletionSource" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor" />
      <templates>
        <template name="TResult" />
      </templates>
      <elements>
        <element api="P:System.Threading.Tasks.TaskCompletionSource`1.Task" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskCompletionSource`1.#ctor">
      <topicdata name=".ctor" group="list" subgroup="overload" memberSubgroup="constructor" pseudo="true" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor" />
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Object)" />
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskCompletionSource`1.SetException">
      <topicdata name="SetException" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="SetException" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Exception)" />
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Collections.Generic.IEnumerable{System.Exception})" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled">
      <topicdata name="TrySetCanceled" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="TrySetCanceled" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled" />
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled(System.Threading.CancellationToken)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskCompletionSource`1.TrySetException">
      <topicdata name="TrySetException" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="TrySetException" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Exception)" />
        <element api="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Collections.Generic.IEnumerable{System.Exception})" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskCompletionSource`1.#ctor" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Object)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskCompletionSource`1.#ctor" />
      <parameters>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskCompletionSource`1.#ctor" />
      <parameters>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskCompletionSource`1.#ctor" />
      <parameters>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCompletionSource`1.SetCanceled">
      <topicdata group="api" />
      <apidata name="SetCanceled" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Collections.Generic.IEnumerable{System.Exception})">
      <topicdata group="api" />
      <apidata name="SetException" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskCompletionSource`1.SetException" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="exceptions">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <type api="T:System.Exception" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Exception)">
      <topicdata group="api" />
      <apidata name="SetException" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskCompletionSource`1.SetException" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="exception">
          <type api="T:System.Exception" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCompletionSource`1.SetResult(`0)">
      <topicdata group="api" />
      <apidata name="SetResult" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="result">
          <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskCompletionSource`1" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.TaskCompletionSource`1.Task">
      <topicdata group="api" />
      <apidata name="Task" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Task" />
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskCompletionSource`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled">
      <topicdata group="api" />
      <apidata name="TrySetCanceled" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled" />
      <proceduredata virtual="false" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled(System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="TrySetCanceled" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Collections.Generic.IEnumerable{System.Exception})">
      <topicdata group="api" />
      <apidata name="TrySetException" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskCompletionSource`1.TrySetException" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="exceptions">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <type api="T:System.Exception" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Exception)">
      <topicdata group="api" />
      <apidata name="TrySetException" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskCompletionSource`1.TrySetException" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="exception">
          <type api="T:System.Exception" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetResult(`0)">
      <topicdata group="api" />
      <apidata name="TrySetResult" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="result">
          <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskCompletionSource`1" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCompletionSource`1" ref="true" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.TaskContinuationOptions">
      <topicdata group="api" />
      <apidata name="TaskContinuationOptions" group="type" subgroup="enumeration" />
      <typedata visibility="public" sealed="true" serializable="true" />
      <elements>
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.None" />
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.PreferFairness" />
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.LongRunning" />
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent" />
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.DenyChildAttach" />
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.HideScheduler" />
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.LazyCancellation" />
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.RunContinuationsAsynchronously" />
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.NotOnRanToCompletion" />
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted" />
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled" />
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion" />
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted" />
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />
        <element api="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.FlagsAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent">
      <topicdata group="api" notopic="" />
      <apidata name="AttachedToParent" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>4</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.DenyChildAttach">
      <topicdata group="api" notopic="" />
      <apidata name="DenyChildAttach" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>8</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">
      <topicdata group="api" notopic="" />
      <apidata name="ExecuteSynchronously" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>524288</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.HideScheduler">
      <topicdata group="api" notopic="" />
      <apidata name="HideScheduler" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>16</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.LazyCancellation">
      <topicdata group="api" notopic="" />
      <apidata name="LazyCancellation" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>32</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.LongRunning">
      <topicdata group="api" notopic="" />
      <apidata name="LongRunning" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>2</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.None">
      <topicdata group="api" notopic="" />
      <apidata name="None" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>0</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled">
      <topicdata group="api" notopic="" />
      <apidata name="NotOnCanceled" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>262144</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted">
      <topicdata group="api" notopic="" />
      <apidata name="NotOnFaulted" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>131072</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.NotOnRanToCompletion">
      <topicdata group="api" notopic="" />
      <apidata name="NotOnRanToCompletion" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>65536</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">
      <topicdata group="api" notopic="" />
      <apidata name="OnlyOnCanceled" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>196608</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted">
      <topicdata group="api" notopic="" />
      <apidata name="OnlyOnFaulted" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>327680</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion">
      <topicdata group="api" notopic="" />
      <apidata name="OnlyOnRanToCompletion" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>393216</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.PreferFairness">
      <topicdata group="api" notopic="" />
      <apidata name="PreferFairness" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>1</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskContinuationOptions.RunContinuationsAsynchronously">
      <topicdata group="api" notopic="" />
      <apidata name="RunContinuationsAsynchronously" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <value>64</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.TaskCreationOptions">
      <topicdata group="api" />
      <apidata name="TaskCreationOptions" group="type" subgroup="enumeration" />
      <typedata visibility="public" sealed="true" serializable="true" />
      <elements>
        <element api="F:System.Threading.Tasks.TaskCreationOptions.None" />
        <element api="F:System.Threading.Tasks.TaskCreationOptions.PreferFairness" />
        <element api="F:System.Threading.Tasks.TaskCreationOptions.LongRunning" />
        <element api="F:System.Threading.Tasks.TaskCreationOptions.AttachedToParent" />
        <element api="F:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach" />
        <element api="F:System.Threading.Tasks.TaskCreationOptions.HideScheduler" />
        <element api="F:System.Threading.Tasks.TaskCreationOptions.RunContinuationsAsynchronously" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.FlagsAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="F:System.Threading.Tasks.TaskCreationOptions.AttachedToParent">
      <topicdata group="api" notopic="" />
      <apidata name="AttachedToParent" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </returns>
      <value>4</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach">
      <topicdata group="api" notopic="" />
      <apidata name="DenyChildAttach" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </returns>
      <value>8</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskCreationOptions.HideScheduler">
      <topicdata group="api" notopic="" />
      <apidata name="HideScheduler" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </returns>
      <value>16</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskCreationOptions.LongRunning">
      <topicdata group="api" notopic="" />
      <apidata name="LongRunning" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </returns>
      <value>2</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskCreationOptions.None">
      <topicdata group="api" notopic="" />
      <apidata name="None" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </returns>
      <value>0</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskCreationOptions.PreferFairness">
      <topicdata group="api" notopic="" />
      <apidata name="PreferFairness" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </returns>
      <value>1</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskCreationOptions.RunContinuationsAsynchronously">
      <topicdata group="api" notopic="" />
      <apidata name="RunContinuationsAsynchronously" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </returns>
      <value>64</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.TaskExtensions">
      <topicdata group="api" />
      <apidata name="TaskExtensions" group="type" subgroup="class" />
      <typedata visibility="public" abstract="true" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="Overload:System.Threading.Tasks.TaskExtensions.Unwrap">
          <element api="M:System.Threading.Tasks.TaskExtensions.Unwrap(System.Threading.Tasks.Task{System.Threading.Tasks.Task})" />
          <element api="M:System.Threading.Tasks.TaskExtensions.Unwrap``1(System.Threading.Tasks.Task{System.Threading.Tasks.Task{``0}})" />
        </element>
      </elements>
      <containers>
        <library assembly="System.Core" module="System.Core" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="Methods.T:System.Threading.Tasks.TaskExtensions">
      <topicdata name="TaskExtensions" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.TaskExtensions" />
      <apidata name="TaskExtensions" group="type" subgroup="class" />
      <typedata visibility="public" abstract="true" sealed="true" serializable="false" />
      <elements>
        <element api="Overload:System.Threading.Tasks.TaskExtensions.Unwrap">
          <element api="M:System.Threading.Tasks.TaskExtensions.Unwrap(System.Threading.Tasks.Task{System.Threading.Tasks.Task})" />
          <element api="M:System.Threading.Tasks.TaskExtensions.Unwrap``1(System.Threading.Tasks.Task{System.Threading.Tasks.Task{``0}})" />
        </element>
      </elements>
      <containers>
        <library assembly="System.Core" module="System.Core" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskExtensions" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskExtensions.Unwrap">
      <topicdata name="Unwrap" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="Unwrap" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskExtensions.Unwrap(System.Threading.Tasks.Task{System.Threading.Tasks.Task})" />
        <element api="M:System.Threading.Tasks.TaskExtensions.Unwrap``1(System.Threading.Tasks.Task{System.Threading.Tasks.Task{``0}})" />
      </elements>
      <containers>
        <library assembly="System.Core" module="System.Core" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskExtensions" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskExtensions.Unwrap``1(System.Threading.Tasks.Task{System.Threading.Tasks.Task{``0}})">
      <topicdata group="api" />
      <apidata name="Unwrap" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.TaskExtensions.Unwrap" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="task">
          <type api="T:System.Threading.Tasks.Task`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskExtensions.Unwrap``1(System.Threading.Tasks.Task{System.Threading.Tasks.Task{``0}})" />
                </specialization>
              </type>
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskExtensions.Unwrap``1(System.Threading.Tasks.Task{System.Threading.Tasks.Task{``0}})" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="System.Core" module="System.Core" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskExtensions" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="M:System.Threading.Tasks.TaskExtensions.Unwrap(System.Threading.Tasks.Task{System.Threading.Tasks.Task})">
      <topicdata group="api" />
      <apidata name="Unwrap" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" overload="Overload:System.Threading.Tasks.TaskExtensions.Unwrap" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="task">
          <type api="T:System.Threading.Tasks.Task`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="System.Core" module="System.Core" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskExtensions" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="T:System.Threading.Tasks.TaskFactory">
      <topicdata group="api" />
      <apidata name="TaskFactory" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.TaskFactory.#ctor" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="Overload:System.Threading.Tasks.TaskFactory.#ctor">
          <element api="M:System.Threading.Tasks.TaskFactory.#ctor" />
          <element api="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll">
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny">
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskFactory.FromAsync">
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult})" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskFactory.StartNew">
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="P:System.Threading.Tasks.TaskFactory.CancellationToken" />
        <element api="P:System.Threading.Tasks.TaskFactory.ContinuationOptions" />
        <element api="P:System.Threading.Tasks.TaskFactory.CreationOptions" />
        <element api="P:System.Threading.Tasks.TaskFactory.Scheduler" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.Permissions.HostProtectionAttribute" ref="true" />
          <argument>
            <type api="T:System.Security.Permissions.SecurityAction" ref="false" />
            <enumValue>
              <field name="LinkDemand" />
            </enumValue>
          </argument>
          <assignment name="Synchronization">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
          <assignment name="ExternalThreading">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
        </attribute>
      </attributes>
    </api>
    <api id="Methods.T:System.Threading.Tasks.TaskFactory">
      <topicdata name="TaskFactory" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.TaskFactory" />
      <apidata name="TaskFactory" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.TaskFactory.#ctor" />
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll">
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny">
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskFactory.FromAsync">
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult})" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskFactory.StartNew">
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" />
      </containers>
    </api>
    <api id="Properties.T:System.Threading.Tasks.TaskFactory">
      <topicdata name="TaskFactory" group="list" subgroup="Properties" typeTopicId="T:System.Threading.Tasks.TaskFactory" />
      <apidata name="TaskFactory" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.TaskFactory.#ctor" />
      <elements>
        <element api="P:System.Threading.Tasks.TaskFactory.CancellationToken" />
        <element api="P:System.Threading.Tasks.TaskFactory.ContinuationOptions" />
        <element api="P:System.Threading.Tasks.TaskFactory.CreationOptions" />
        <element api="P:System.Threading.Tasks.TaskFactory.Scheduler" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskFactory.#ctor">
      <topicdata name=".ctor" group="list" subgroup="overload" memberSubgroup="constructor" pseudo="true" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskFactory.#ctor" />
        <element api="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll">
      <topicdata name="ContinueWhenAll" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny">
      <topicdata name="ContinueWhenAny" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskFactory.FromAsync">
      <topicdata name="FromAsync" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult})" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskFactory.StartNew">
      <topicdata name="StartNew" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action)" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.#ctor">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskFactory.#ctor" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskFactory.#ctor" />
      <parameters>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskFactory.#ctor" />
      <parameters>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskFactory.#ctor" />
      <parameters>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskFactory.#ctor" />
      <parameters>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.TaskFactory.CancellationToken">
      <topicdata group="api" />
      <apidata name="CancellationToken" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_CancellationToken" />
      <returns>
        <type api="T:System.Threading.CancellationToken" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.TaskFactory.ContinuationOptions">
      <topicdata group="api" />
      <apidata name="ContinuationOptions" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_ContinuationOptions" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task" ref="true" />
              </arrayOf>
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task" ref="true" />
              </arrayOf>
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task" ref="true" />
              </arrayOf>
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task" ref="true" />
              </arrayOf>
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task" ref="true" />
              </arrayOf>
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task" ref="true" />
              </arrayOf>
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task" ref="true" />
              </arrayOf>
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task" ref="true" />
              </arrayOf>
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task`1" ref="true">
                  <specialization>
                    <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})" />
                  </specialization>
                </type>
              </arrayOf>
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task`1" ref="true">
                  <specialization>
                    <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)" />
                  </specialization>
                </type>
              </arrayOf>
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task`1" ref="true">
                  <specialization>
                    <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
                  </specialization>
                </type>
              </arrayOf>
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task`1" ref="true">
                  <specialization>
                    <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)" />
                  </specialization>
                </type>
              </arrayOf>
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task`1" ref="true">
                  <specialization>
                    <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
                  </specialization>
                </type>
              </arrayOf>
              <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task`1" ref="true">
                  <specialization>
                    <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
                  </specialization>
                </type>
              </arrayOf>
              <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task`1" ref="true">
                  <specialization>
                    <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
                  </specialization>
                </type>
              </arrayOf>
              <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task`1" ref="true">
                  <specialization>
                    <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
                  </specialization>
                </type>
              </arrayOf>
              <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})" />
                </specialization>
              </type>
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
                </specialization>
              </type>
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
                </specialization>
              </type>
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)" />
                </specialization>
              </type>
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
                </specialization>
              </type>
              <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
                </specialization>
              </type>
              <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
                </specialization>
              </type>
              <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
                </specialization>
              </type>
              <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.TaskFactory.CreationOptions">
      <topicdata group="api" />
      <apidata name="CreationOptions" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_CreationOptions" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`4" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`4" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`4" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`4" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
        <template name="TArg2" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`5" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
              <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
        </parameter>
        <parameter name="arg2">
          <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
        <template name="TArg2" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`5" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="arg2">
          <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
        <template name="TArg2" />
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`5" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
              <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="2" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
        </parameter>
        <parameter name="arg2">
          <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="2" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
        <template name="TArg2" />
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`5" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="2" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="arg2">
          <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="2" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
        <template name="TArg2" />
        <template name="TArg3" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`6" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
              <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
              <template name="TArg3" index="2" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
        </parameter>
        <parameter name="arg2">
          <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
        </parameter>
        <parameter name="arg3">
          <template name="TArg3" index="2" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
        <template name="TArg2" />
        <template name="TArg3" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`6" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <template name="TArg3" index="2" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="arg2">
          <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="arg3">
          <template name="TArg3" index="2" api="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
        <template name="TArg2" />
        <template name="TArg3" />
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`6" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
              <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
              <template name="TArg3" index="2" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="3" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
        </parameter>
        <parameter name="arg2">
          <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
        </parameter>
        <parameter name="arg3">
          <template name="TArg3" index="2" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="3" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
        <template name="TArg2" />
        <template name="TArg3" />
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`6" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <template name="TArg3" index="2" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="3" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="arg2">
          <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="arg3">
          <template name="TArg3" index="2" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="3" api="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult})">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="asyncResult">
          <type api="T:System.IAsyncResult" ref="true" />
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="asyncResult">
          <type api="T:System.IAsyncResult" ref="true" />
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="asyncResult">
          <type api="T:System.IAsyncResult" ref="true" />
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="asyncResult">
          <type api="T:System.IAsyncResult" ref="true" />
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="asyncResult">
          <type api="T:System.IAsyncResult" ref="true" />
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="asyncResult">
          <type api="T:System.IAsyncResult" ref="true" />
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.TaskFactory.Scheduler">
      <topicdata group="api" />
      <apidata name="Scheduler" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Scheduler" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory.StartNew" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TResult" />
      </templates>
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory" ref="true" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.TaskFactory`1">
      <topicdata group="api" />
      <apidata name="TaskFactory" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.TaskFactory`1.#ctor" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <templates>
        <template name="TResult" />
      </templates>
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="Overload:System.Threading.Tasks.TaskFactory`1.#ctor">
          <element api="M:System.Threading.Tasks.TaskFactory`1.#ctor" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll">
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0})" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0})" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny">
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0})" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0})" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskFactory`1.FromAsync">
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0})" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskFactory`1.StartNew">
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0})" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="P:System.Threading.Tasks.TaskFactory`1.CancellationToken" />
        <element api="P:System.Threading.Tasks.TaskFactory`1.ContinuationOptions" />
        <element api="P:System.Threading.Tasks.TaskFactory`1.CreationOptions" />
        <element api="P:System.Threading.Tasks.TaskFactory`1.Scheduler" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.Permissions.HostProtectionAttribute" ref="true" />
          <argument>
            <type api="T:System.Security.Permissions.SecurityAction" ref="false" />
            <enumValue>
              <field name="LinkDemand" />
            </enumValue>
          </argument>
          <assignment name="Synchronization">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
          <assignment name="ExternalThreading">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
        </attribute>
      </attributes>
    </api>
    <api id="Methods.T:System.Threading.Tasks.TaskFactory`1">
      <topicdata name="TaskFactory" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.TaskFactory`1" />
      <apidata name="TaskFactory" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.TaskFactory`1.#ctor" />
      <templates>
        <template name="TResult" />
      </templates>
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll">
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0})" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0})" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny">
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0})" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0})" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.Tasks.TaskContinuationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskFactory`1.FromAsync">
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0})" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </element>
        <element api="Overload:System.Threading.Tasks.TaskFactory`1.StartNew">
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0})" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
          <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
        </element>
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" />
      </containers>
    </api>
    <api id="Properties.T:System.Threading.Tasks.TaskFactory`1">
      <topicdata name="TaskFactory" group="list" subgroup="Properties" typeTopicId="T:System.Threading.Tasks.TaskFactory`1" />
      <apidata name="TaskFactory" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" defaultConstructor="M:System.Threading.Tasks.TaskFactory`1.#ctor" />
      <templates>
        <template name="TResult" />
      </templates>
      <elements>
        <element api="P:System.Threading.Tasks.TaskFactory`1.CancellationToken" />
        <element api="P:System.Threading.Tasks.TaskFactory`1.ContinuationOptions" />
        <element api="P:System.Threading.Tasks.TaskFactory`1.CreationOptions" />
        <element api="P:System.Threading.Tasks.TaskFactory`1.Scheduler" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskFactory`1.#ctor">
      <topicdata name=".ctor" group="list" subgroup="overload" memberSubgroup="constructor" pseudo="true" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskFactory`1.#ctor" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll">
      <topicdata name="ContinueWhenAll" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0})" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0})" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny">
      <topicdata name="ContinueWhenAny" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0})" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0})" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.Tasks.TaskContinuationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskFactory`1.FromAsync">
      <topicdata name="FromAsync" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0})" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskFactory`1.StartNew">
      <topicdata name="StartNew" group="list" subgroup="overload" memberSubgroup="method" pseudo="true" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0})" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
        <element api="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.#ctor">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskFactory`1.#ctor" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskFactory`1.#ctor" />
      <parameters>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskFactory`1.#ctor" />
      <parameters>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskFactory`1.#ctor" />
      <parameters>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskFactory`1.#ctor" />
      <parameters>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.TaskFactory`1.CancellationToken">
      <topicdata group="api" />
      <apidata name="CancellationToken" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_CancellationToken" />
      <returns>
        <type api="T:System.Threading.CancellationToken" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.TaskFactory`1.ContinuationOptions">
      <topicdata group="api" />
      <apidata name="ContinuationOptions" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_ContinuationOptions" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0})">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task" ref="true" />
              </arrayOf>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task" ref="true" />
              </arrayOf>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task" ref="true" />
              </arrayOf>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task" ref="true" />
              </arrayOf>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0})">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0})" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task`1" ref="true">
                  <specialization>
                    <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0})" />
                  </specialization>
                </type>
              </arrayOf>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task`1" ref="true">
                  <specialization>
                    <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken)" />
                  </specialization>
                </type>
              </arrayOf>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task`1" ref="true">
                  <specialization>
                    <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
                  </specialization>
                </type>
              </arrayOf>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAll" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.Tasks.TaskContinuationOptions)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <arrayOf rank="1">
                <type api="T:System.Threading.Tasks.Task`1" ref="true">
                  <specialization>
                    <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.Tasks.TaskContinuationOptions)" />
                  </specialization>
                </type>
              </arrayOf>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0})">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0})">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0})" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0})" />
                </specialization>
              </type>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken)" />
                </specialization>
              </type>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
                </specialization>
              </type>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.Tasks.TaskContinuationOptions)">
      <topicdata group="api" />
      <apidata name="ContinueWhenAny" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TAntecedentResult" />
      </templates>
      <parameters>
        <parameter name="tasks">
          <arrayOf rank="1">
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.Tasks.TaskContinuationOptions)" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="continuationFunction">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Threading.Tasks.Task`1" ref="true">
                <specialization>
                  <template name="TAntecedentResult" index="0" api="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.Tasks.TaskContinuationOptions)" />
                </specialization>
              </type>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="continuationOptions">
          <type api="T:System.Threading.Tasks.TaskContinuationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.TaskFactory`1.CreationOptions">
      <topicdata group="api" />
      <apidata name="CreationOptions" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_CreationOptions" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.FromAsync" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.FromAsync" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`3" ref="true">
            <specialization>
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`4" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`4" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
        <template name="TArg2" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`5" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object)" />
              <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object)" />
        </parameter>
        <parameter name="arg2">
          <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
        <template name="TArg2" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`5" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="arg2">
          <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
        <template name="TArg2" />
        <template name="TArg3" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`6" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object)" />
              <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object)" />
              <template name="TArg3" index="2" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object)" />
        </parameter>
        <parameter name="arg2">
          <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object)" />
        </parameter>
        <parameter name="arg3">
          <template name="TArg3" index="2" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.FromAsync" />
      <proceduredata virtual="false" />
      <templates>
        <template name="TArg1" />
        <template name="TArg2" />
        <template name="TArg3" />
      </templates>
      <parameters>
        <parameter name="beginMethod">
          <type api="T:System.Func`6" ref="true">
            <specialization>
              <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <template name="TArg3" index="2" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
              <type api="T:System.AsyncCallback" ref="true" />
              <type api="T:System.Object" ref="true" />
              <type api="T:System.IAsyncResult" ref="true" />
            </specialization>
          </type>
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="arg1">
          <template name="TArg1" index="0" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="arg2">
          <template name="TArg2" index="1" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="arg3">
          <template name="TArg3" index="2" api="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0})">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.FromAsync" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="asyncResult">
          <type api="T:System.IAsyncResult" ref="true" />
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.FromAsync" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="asyncResult">
          <type api="T:System.IAsyncResult" ref="true" />
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="FromAsync" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.FromAsync" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="asyncResult">
          <type api="T:System.IAsyncResult" ref="true" />
        </parameter>
        <parameter name="endMethod">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.IAsyncResult" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.TaskFactory`1.Scheduler">
      <topicdata group="api" />
      <apidata name="Scheduler" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Scheduler" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0})">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`1" ref="true">
            <specialization>
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="cancellationToken">
          <type api="T:System.Threading.CancellationToken" ref="false" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
        <parameter name="scheduler">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <topicdata group="api" />
      <apidata name="StartNew" group="member" subgroup="method" />
      <memberdata visibility="public" overload="Overload:System.Threading.Tasks.TaskFactory`1.StartNew" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="function">
          <type api="T:System.Func`2" ref="true">
            <specialization>
              <type api="T:System.Object" ref="true" />
              <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="state">
          <type api="T:System.Object" ref="true" />
        </parameter>
        <parameter name="creationOptions">
          <type api="T:System.Threading.Tasks.TaskCreationOptions" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.Task`1" ref="true">
          <specialization>
            <template name="TResult" index="0" api="T:System.Threading.Tasks.TaskFactory`1" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskFactory`1" ref="true" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.TaskScheduler">
      <topicdata group="api" />
      <apidata name="TaskScheduler" group="type" subgroup="class" />
      <typedata visibility="public" abstract="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="M:System.Threading.Tasks.TaskScheduler.#ctor" />
        <element api="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
        <element api="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
        <element api="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
        <element api="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
        <element api="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
        <element api="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
        <element api="P:System.Threading.Tasks.TaskScheduler.Current" />
        <element api="P:System.Threading.Tasks.TaskScheduler.Default" />
        <element api="P:System.Threading.Tasks.TaskScheduler.Id" />
        <element api="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.Permissions.HostProtectionAttribute" ref="true" />
          <argument>
            <type api="T:System.Security.Permissions.SecurityAction" ref="false" />
            <enumValue>
              <field name="LinkDemand" />
            </enumValue>
          </argument>
          <assignment name="Synchronization">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
          <assignment name="ExternalThreading">
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </assignment>
        </attribute>
      </attributes>
    </api>
    <api id="Methods.T:System.Threading.Tasks.TaskScheduler">
      <topicdata name="TaskScheduler" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.TaskScheduler" />
      <apidata name="TaskScheduler" group="type" subgroup="class" />
      <typedata visibility="public" abstract="true" serializable="false" />
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
        <element api="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
        <element api="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
        <element api="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
        <element api="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
        <element api="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" />
      </containers>
    </api>
    <api id="Properties.T:System.Threading.Tasks.TaskScheduler">
      <topicdata name="TaskScheduler" group="list" subgroup="Properties" typeTopicId="T:System.Threading.Tasks.TaskScheduler" />
      <apidata name="TaskScheduler" group="type" subgroup="class" />
      <typedata visibility="public" abstract="true" serializable="false" />
      <elements>
        <element api="P:System.Threading.Tasks.TaskScheduler.Current" />
        <element api="P:System.Threading.Tasks.TaskScheduler.Default" />
        <element api="P:System.Threading.Tasks.TaskScheduler.Id" />
        <element api="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" />
      </containers>
    </api>
    <api id="Events.T:System.Threading.Tasks.TaskScheduler">
      <topicdata name="TaskScheduler" group="list" subgroup="Events" typeTopicId="T:System.Threading.Tasks.TaskScheduler" />
      <apidata name="TaskScheduler" group="type" subgroup="class" />
      <typedata visibility="public" abstract="true" serializable="false" />
      <elements>
        <element api="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskScheduler.#ctor">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="family" special="true" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.TaskScheduler.Current">
      <topicdata group="api" />
      <apidata name="Current" group="member" subgroup="property" />
      <memberdata visibility="public" static="true" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Current" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.TaskScheduler.Default">
      <topicdata group="api" />
      <apidata name="Default" group="member" subgroup="property" />
      <memberdata visibility="public" static="true" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Default" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
      <topicdata group="api" />
      <apidata name="FromCurrentSynchronizationContext" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <proceduredata virtual="false" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
      <topicdata group="api" />
      <apidata name="GetScheduledTasks" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <proceduredata abstract="true" virtual="true" />
      <returns>
        <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
          <specialization>
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.SecurityCriticalAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="P:System.Threading.Tasks.TaskScheduler.Id">
      <topicdata group="api" />
      <apidata name="Id" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Id" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
      <topicdata group="api" />
      <apidata name="MaximumConcurrencyLevel" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="true" />
      <propertydata get="true" />
      <getter name="get_MaximumConcurrencyLevel" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
      <topicdata group="api" />
      <apidata name="QueueTask" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <proceduredata abstract="true" virtual="true" />
      <parameters>
        <parameter name="task">
          <type api="T:System.Threading.Tasks.Task" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.SecurityCriticalAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
      <topicdata group="api" />
      <apidata name="TryDequeue" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <proceduredata virtual="true" />
      <parameters>
        <parameter name="task">
          <type api="T:System.Threading.Tasks.Task" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.SecurityCriticalAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
      <topicdata group="api" />
      <apidata name="TryExecuteTask" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="task">
          <type api="T:System.Threading.Tasks.Task" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.SecurityCriticalAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
      <topicdata group="api" />
      <apidata name="TryExecuteTaskInline" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <proceduredata abstract="true" virtual="true" />
      <parameters>
        <parameter name="task">
          <type api="T:System.Threading.Tasks.Task" ref="true" />
        </parameter>
        <parameter name="taskWasPreviouslyQueued">
          <type api="T:System.Boolean" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.SecurityCriticalAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
      <topicdata group="api" />
      <apidata name="UnobservedTaskException" group="member" subgroup="event" />
      <memberdata visibility="public" static="true" />
      <proceduredata virtual="false" />
      <eventdata add="true" remove="true" />
      <adder name="add_UnobservedTaskException">
        <attributes>
          <attribute>
            <type api="T:System.Security.SecurityCriticalAttribute" ref="true" />
          </attribute>
        </attributes>
      </adder>
      <remover name="remove_UnobservedTaskException">
        <attributes>
          <attribute>
            <type api="T:System.Security.SecurityCriticalAttribute" ref="true" />
          </attribute>
        </attributes>
      </remover>
      <eventhandler>
        <type api="T:System.EventHandler`1" ref="true">
          <specialization>
            <type api="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs" ref="true" />
          </specialization>
        </type>
      </eventhandler>
      <eventargs>
        <type api="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs" ref="true" />
      </eventargs>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.TaskSchedulerException">
      <topicdata group="api" />
      <apidata name="TaskSchedulerException" group="type" subgroup="class" />
      <typedata visibility="public" serializable="true" defaultConstructor="M:System.Threading.Tasks.TaskSchedulerException.#ctor" />
      <family>
        <ancestors>
          <type api="T:System.Exception" ref="true" />
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="E:System.Exception.SerializeObjectState" />
        <element api="M:System.Exception.GetBaseException" />
        <element api="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
        <element api="M:System.Exception.GetType" />
        <element api="M:System.Exception.ToString" />
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="Overload:System.Threading.Tasks.TaskSchedulerException.#ctor">
          <element api="M:System.Threading.Tasks.TaskSchedulerException.#ctor" />
          <element api="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.Exception)" />
          <element api="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.String)" />
          <element api="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
          <element api="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.String,System.Exception)" />
        </element>
        <element api="P:System.Exception.Data" />
        <element api="P:System.Exception.HelpLink" />
        <element api="P:System.Exception.HResult" />
        <element api="P:System.Exception.InnerException" />
        <element api="P:System.Exception.Message" />
        <element api="P:System.Exception.Source" />
        <element api="P:System.Exception.StackTrace" />
        <element api="P:System.Exception.TargetSite" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
    </api>
    <api id="Methods.T:System.Threading.Tasks.TaskSchedulerException">
      <topicdata name="TaskSchedulerException" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.TaskSchedulerException" />
      <apidata name="TaskSchedulerException" group="type" subgroup="class" />
      <typedata visibility="public" serializable="true" defaultConstructor="M:System.Threading.Tasks.TaskSchedulerException.#ctor" />
      <elements>
        <element api="M:System.Exception.GetBaseException" />
        <element api="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
        <element api="M:System.Exception.GetType" />
        <element api="M:System.Exception.ToString" />
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.MemberwiseClone" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskSchedulerException" />
      </containers>
    </api>
    <api id="Properties.T:System.Threading.Tasks.TaskSchedulerException">
      <topicdata name="TaskSchedulerException" group="list" subgroup="Properties" typeTopicId="T:System.Threading.Tasks.TaskSchedulerException" />
      <apidata name="TaskSchedulerException" group="type" subgroup="class" />
      <typedata visibility="public" serializable="true" defaultConstructor="M:System.Threading.Tasks.TaskSchedulerException.#ctor" />
      <elements>
        <element api="P:System.Exception.Data" />
        <element api="P:System.Exception.HelpLink" />
        <element api="P:System.Exception.HResult" />
        <element api="P:System.Exception.InnerException" />
        <element api="P:System.Exception.Message" />
        <element api="P:System.Exception.Source" />
        <element api="P:System.Exception.StackTrace" />
        <element api="P:System.Exception.TargetSite" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskSchedulerException" />
      </containers>
    </api>
    <api id="Events.T:System.Threading.Tasks.TaskSchedulerException">
      <topicdata name="TaskSchedulerException" group="list" subgroup="Events" typeTopicId="T:System.Threading.Tasks.TaskSchedulerException" />
      <apidata name="TaskSchedulerException" group="type" subgroup="class" />
      <typedata visibility="public" serializable="true" defaultConstructor="M:System.Threading.Tasks.TaskSchedulerException.#ctor" />
      <elements>
        <element api="E:System.Exception.SerializeObjectState" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskSchedulerException" />
      </containers>
    </api>
    <api id="Overload:System.Threading.Tasks.TaskSchedulerException.#ctor">
      <topicdata name=".ctor" group="list" subgroup="overload" memberSubgroup="constructor" pseudo="true" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <elements>
        <element api="M:System.Threading.Tasks.TaskSchedulerException.#ctor" />
        <element api="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.Exception)" />
        <element api="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.String)" />
        <element api="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
        <element api="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.String,System.Exception)" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskSchedulerException" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskSchedulerException.#ctor">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskSchedulerException.#ctor" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskSchedulerException" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.Exception)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskSchedulerException.#ctor" />
      <parameters>
        <parameter name="innerException">
          <type api="T:System.Exception" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskSchedulerException" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="family" special="true" overload="Overload:System.Threading.Tasks.TaskSchedulerException.#ctor" />
      <parameters>
        <parameter name="info">
          <type api="T:System.Runtime.Serialization.SerializationInfo" ref="true" />
        </parameter>
        <parameter name="context">
          <type api="T:System.Runtime.Serialization.StreamingContext" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskSchedulerException" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.String)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskSchedulerException.#ctor" />
      <parameters>
        <parameter name="message">
          <type api="T:System.String" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskSchedulerException" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.String,System.Exception)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" overload="Overload:System.Threading.Tasks.TaskSchedulerException.#ctor" />
      <parameters>
        <parameter name="message">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="innerException">
          <type api="T:System.Exception" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskSchedulerException" ref="true" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.TaskStatus">
      <topicdata group="api" />
      <apidata name="TaskStatus" group="type" subgroup="enumeration" />
      <typedata visibility="public" sealed="true" serializable="false" />
      <elements>
        <element api="F:System.Threading.Tasks.TaskStatus.Created" />
        <element api="F:System.Threading.Tasks.TaskStatus.WaitingForActivation" />
        <element api="F:System.Threading.Tasks.TaskStatus.WaitingToRun" />
        <element api="F:System.Threading.Tasks.TaskStatus.Running" />
        <element api="F:System.Threading.Tasks.TaskStatus.WaitingForChildrenToComplete" />
        <element api="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />
        <element api="F:System.Threading.Tasks.TaskStatus.Canceled" />
        <element api="F:System.Threading.Tasks.TaskStatus.Faulted" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskStatus.Canceled">
      <topicdata group="api" notopic="" />
      <apidata name="Canceled" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </returns>
      <value>6</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskStatus.Created">
      <topicdata group="api" notopic="" />
      <apidata name="Created" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </returns>
      <value>0</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskStatus.Faulted">
      <topicdata group="api" notopic="" />
      <apidata name="Faulted" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </returns>
      <value>7</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskStatus.RanToCompletion">
      <topicdata group="api" notopic="" />
      <apidata name="RanToCompletion" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </returns>
      <value>5</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskStatus.Running">
      <topicdata group="api" notopic="" />
      <apidata name="Running" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </returns>
      <value>3</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskStatus.WaitingForActivation">
      <topicdata group="api" notopic="" />
      <apidata name="WaitingForActivation" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </returns>
      <value>1</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskStatus.WaitingForChildrenToComplete">
      <topicdata group="api" notopic="" />
      <apidata name="WaitingForChildrenToComplete" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </returns>
      <value>4</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </containers>
    </api>
    <api id="F:System.Threading.Tasks.TaskStatus.WaitingToRun">
      <topicdata group="api" notopic="" />
      <apidata name="WaitingToRun" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </returns>
      <value>2</value>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.TaskStatus" ref="false" />
      </containers>
    </api>
    <api id="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs">
      <topicdata group="api" />
      <apidata name="UnobservedTaskExceptionEventArgs" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.EventArgs" ref="true" />
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="M:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.#ctor(System.AggregateException)" />
        <element api="M:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.SetObserved" />
        <element api="P:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.Exception" />
        <element api="P:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.Observed" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
      </containers>
    </api>
    <api id="Methods.T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs">
      <topicdata name="UnobservedTaskExceptionEventArgs" group="list" subgroup="Methods" typeTopicId="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs" />
      <apidata name="UnobservedTaskExceptionEventArgs" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" />
      <elements>
        <element api="M:System.Object.Equals(System.Object)" />
        <element api="M:System.Object.Finalize" />
        <element api="M:System.Object.GetHashCode" />
        <element api="M:System.Object.GetType" />
        <element api="M:System.Object.MemberwiseClone" />
        <element api="M:System.Object.ToString" />
        <element api="M:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.SetObserved" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs" />
      </containers>
    </api>
    <api id="Properties.T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs">
      <topicdata name="UnobservedTaskExceptionEventArgs" group="list" subgroup="Properties" typeTopicId="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs" />
      <apidata name="UnobservedTaskExceptionEventArgs" group="type" subgroup="class" />
      <typedata visibility="public" serializable="false" />
      <elements>
        <element api="P:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.Exception" />
        <element api="P:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.Observed" />
      </elements>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.#ctor(System.AggregateException)">
      <topicdata group="api" />
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <parameters>
        <parameter name="exception">
          <type api="T:System.AggregateException" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.Exception">
      <topicdata group="api" />
      <apidata name="Exception" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Exception" />
      <returns>
        <type api="T:System.AggregateException" ref="true" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs" ref="true" />
      </containers>
    </api>
    <api id="P:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.Observed">
      <topicdata group="api" />
      <apidata name="Observed" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Observed" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs" ref="true" />
      </containers>
    </api>
    <api id="M:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.SetObserved">
      <topicdata group="api" />
      <apidata name="SetObserved" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="mscorlib" module="mscorlib" kind="DynamicallyLinkedLibrary">
          <assemblydata version="4.8.3761.0" />
        </library>
        <namespace api="N:System.Threading.Tasks" />
        <type api="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs" ref="true" />
      </containers>
    </api>
  </apis>
</reflection>